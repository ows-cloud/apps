diff --git a/addons/auth_signup/models/res_users.py b/addons/auth_signup/models/res_users.py
index d93e7c706..458aef840 100644
--- a/addons/auth_signup/models/res_users.py
+++ b/addons/auth_signup/models/res_users.py
@@ -194,7 +194,8 @@ class ResUsers(models.Model):
             'partner_to': False,
             'scheduled_date': False,
         }
-        template.write(template_values)
+        # template.write(template_values)
+        # ACCESS ERROR: Users cannot edit system record.
 
         for user in self:
             if not user.email:
diff --git a/addons/mail/models/update.py b/addons/mail/models/update.py
index edf5b4f2c..9be029ec9 100644
--- a/addons/mail/models/update.py
+++ b/addons/mail/models/update.py
@@ -98,6 +98,10 @@ class PublisherWarrantyContract(AbstractModel):
             # old behavior based on res.log; now on mail.message, that is not necessarily installed
             user = self.env['res.users'].sudo().browse(SUPERUSER_ID)
             poster = self.sudo().env.ref('mail.channel_all_employees')
+            try:
+                poster = self.env['mail.channel'].search([('company_id', '=', self.env.company.id), ('all_employees', '=', True)])
+            except:
+                pass
             if not (poster and poster.exists()):
                 if not user.exists():
                     return True
diff --git a/odoo/addons/base/models/__init__.py b/odoo/addons/base/models/__init__.py
index bdc3d0b1a..36463b9e8 100644
--- a/odoo/addons/base/models/__init__.py
+++ b/odoo/addons/base/models/__init__.py
@@ -2,6 +2,7 @@
 # Part of Odoo. See LICENSE file for full copyright and licensing details.
 
 from . import assetsbundle
+from . import base
 from . import qweb
 
 from . import ir_model
diff --git a/odoo/addons/base/models/base.py b/odoo/addons/base/models/base.py
new file mode 100644
index 000000000..c5a34a2a7
--- /dev/null
+++ b/odoo/addons/base/models/base.py
@@ -0,0 +1,79 @@
+from odoo import api, fields, models
+from odoo.exceptions import UserError
+from . import ir_model
+
+"""
+If company_id doesn't exist, look for it in a related record.
+Key: model name
+Value: field name to reference another record.
+"""
+FIELD_NAME_TO_GET_COMPANY = {
+    'ir.default': 'user_id',
+    'ir.model.data': 'res_id',
+    'ir.property': 'res_id',
+    'website.menu': 'website_id',
+}
+
+class Base(models.AbstractModel):
+    _inherit = 'base'
+
+    def create(self, vals_list):
+        """
+        This code cannot be inside multicompany_base; then it is not active on installing/updating modules.
+
+        If multicompany_base is installed:
+            Don't accept {'company_id': False}
+            (e.g. stock.location from XML)
+        """
+        for vals_dict in vals_list:
+            if 'company_id' in vals_dict and not vals_dict['company_id']:
+                if self.env['ir.module.module'].search([('name', '=', 'multicompany_base')]).state == 'installed':
+                    vals_dict['company_id'] = self.related_company(vals_dict).id
+        return super(Base, self).create(vals_list)
+
+    def related_company(self, record_or_values):
+        field_name = FIELD_NAME_TO_GET_COMPANY.get(self._name)
+        if not field_name:
+            return self.env.company
+
+        # implicit parameter: record_or_value
+        def _get_value(key):
+            if type(record_or_values) is dict:
+                values = record_or_values
+                return values[key]
+            else:
+                record = record_or_values
+                return getattr(record, key)
+
+        field = self._fields[field_name]
+        if field.type == 'many2one':
+            comodel_name = field.comodel_name
+            res_id = _get_value(field_name)
+        elif field.type == 'reference':
+            comodel_name, res_id = _get_value(field_name).split(',')
+            res_id = int(res_id)
+        elif field.type == 'many2one_reference':
+            comodel_name = _get_value(field.model_field)
+            res_id = _get_value(field_name)
+        else:
+            raise UserError('_get_company error')
+        related_record = self.env[comodel_name].browse(res_id)
+        return related_record.company_id
+
+    """
+    MULTICOMPANY CONTROLLER PATCHES
+    When the active company is not the user's default company,
+    controllers may not know the company of a record,
+    and sudo() is necessary to find out.
+    In patches to fix controllers,
+    the methods .my_company() and .with_my_company() are often very useful.
+    Then sudo() is only one place here, not in every controller patch.
+    """
+
+    def my_company(self):
+        company = self.sudo().mapped('company_id')
+        if len(company) == 1:
+            return company
+
+    def with_my_company(self):
+        return self.with_company(self.my_company())
\ No newline at end of file
diff --git a/odoo/addons/base/models/res_company.py b/odoo/addons/base/models/res_company.py
index 3b20cb9d7..854d752fe 100644
--- a/odoo/addons/base/models/res_company.py
+++ b/odoo/addons/base/models/res_company.py
@@ -213,7 +213,7 @@ class Company(models.Model):
         self.clear_caches()
         company = super(Company, self).create(vals)
         # The write is made on the user to set it automatically in the multi company group.
-        self.env.user.write({'company_ids': [(4, company.id)]})
+        self.env.user.sudo().write({'company_ids': [(4, company.id)]})
 
         # Make sure that the selected currency is enabled
         if vals.get('currency_id'):
diff --git a/odoo/addons/base/models/res_partner.py b/odoo/addons/base/models/res_partner.py
index 8b50afad4..2fd5cbe00 100644
--- a/odoo/addons/base/models/res_partner.py
+++ b/odoo/addons/base/models/res_partner.py
@@ -524,6 +524,7 @@ class Partner(models.Model):
             self.invalidate_cache(['user_ids'], self._ids)
             for partner in self:
                 if partner.active and partner.user_ids:
+                  if partner.user_ids[0].active:
                     raise ValidationError(_('You cannot archive a contact linked to a portal or internal user.'))
         # res.partner must only allow to set the company_id of a partner if it
         # is the same as the company of all users that inherit from this partner
diff --git a/odoo/addons/base/models/res_users.py b/odoo/addons/base/models/res_users.py
index 34f35ac82..61cefe775 100644
--- a/odoo/addons/base/models/res_users.py
+++ b/odoo/addons/base/models/res_users.py
@@ -659,6 +659,7 @@ class Users(models.Model):
     def check_super(self, passwd):
         return check_super(passwd)
 
+    # Replaced in multicompany_base
     @api.model
     def _update_last_login(self):
         # only create new records to avoid any side-effect on concurrent transactions
diff --git a/odoo/models.py b/odoo/models.py
index 34882ef5c..606ce2119 100644
--- a/odoo/models.py
+++ b/odoo/models.py
@@ -800,25 +800,43 @@ class BaseModel(MetaModel('DummyModel', (object,), {'_register': False})):
             for r in missing
         )
         fields = ['module', 'model', 'name', 'res_id']
+        if self.env['ir.model.fields'].search([('name', '=', 'company_id')]):
+            fields.append('company_id')
 
         # disable eventual async callback / support for the extent of
         # the COPY FROM, as these are apparently incompatible
         callback = psycopg2.extensions.get_wait_callback()
         psycopg2.extensions.set_wait_callback(None)
         try:
-            cr.copy_from(io.StringIO(
-                u'\n'.join(
-                    u"%s\t%s\t%s\t%d" % (
-                        modname,
-                        record._name,
-                        xids[record.id][1],
-                        record.id,
-                    )
-                    for record in missing
-                )),
-                table='ir_model_data',
-                columns=fields,
-            )
+            if 'company_id' in fields:
+                cr.copy_from(io.StringIO(
+                    u'\n'.join(
+                        u"%s\t%s\t%s\t%d\t%d" % (
+                            modname,
+                            record._name,
+                            xids[record.id][1],
+                            record.id,
+                            record.company_id.id,
+                        )
+                        for record in missing
+                    )),
+                    table='ir_model_data',
+                    columns=fields,
+                )
+            else:
+                cr.copy_from(io.StringIO(
+                    u'\n'.join(
+                        u"%s\t%s\t%s\t%d" % (
+                            modname,
+                            record._name,
+                            xids[record.id][1],
+                            record.id,
+                        )
+                        for record in missing
+                    )),
+                    table='ir_model_data',
+                    columns=fields,
+                )
         finally:
             psycopg2.extensions.set_wait_callback(callback)
         self.env['ir.model.data'].invalidate_cache(fnames=fields)
@@ -3251,10 +3269,12 @@ Fields:
         """ Check the companies of the values of the given field names.
 
         :param list fnames: names of relational fields to check
-        :raises UserError: if the `company_id` of the value of any field is not
-            in `[False, self.company_id]` (or `self` if
+        :raises UserError: if the `company_id.id` of the value of any field is not
+            in `[False, self.company_id.id]` (or `self.id` if
             :class:`~odoo.addons.base.models.res_company`).
 
+        If multicompany_base is installed, also accept company_id 1.
+
         For :class:`~odoo.addons.base.models.res_users` relational fields,
         verifies record company is in `company_ids` fields.
 
@@ -3279,6 +3299,9 @@ Fields:
             return
 
         inconsistencies = []
+        consistent_company_ids = [False]
+        if self.env['ir.module.module'].search([('name', '=', 'multicompany_base')]).state == 'installed':
+            consistent_company_ids.append(1)
         for record in self:
             company = record.company_id if record._name != 'res.company' else record
             # The first part of the check verifies that all records linked via relation fields are compatible
@@ -3287,9 +3310,9 @@ Fields:
                 corecord = record.sudo()[name]
                 # Special case with `res.users` since an user can belong to multiple companies.
                 if corecord._name == 'res.users' and corecord.company_ids:
-                    if not (company <= corecord.company_ids):
+                    if not (company.id in corecord.company_ids.ids + consistent_company_ids):
                         inconsistencies.append((record, name, corecord))
-                elif not (corecord.company_id <= company):
+                elif not (corecord.company_id.id in [company.id] + consistent_company_ids):
                     inconsistencies.append((record, name, corecord))
             # The second part of the check (for property / company-dependent fields) verifies that the records
             # linked via those relation fields are compatible with the company that owns the property value, i.e.
@@ -3300,9 +3323,9 @@ Fields:
                 # Special case with `res.users` since an user can belong to multiple companies.
                 corecord = record.sudo()[name]
                 if corecord._name == 'res.users' and corecord.company_ids:
-                    if not (company <= corecord.company_ids):
+                    if not (company.id in corecord.company_ids.ids + consistent_company_ids):
                         inconsistencies.append((record, name, corecord))
-                elif not (corecord.company_id <= company):
+                elif not (corecord.company_id.id in [company.id] + consistent_company_ids):
                     inconsistencies.append((record, name, corecord))
 
         if inconsistencies:
diff --git a/odoo/modules/loading.py b/odoo/modules/loading.py
index 8093f14b1..a064632db 100644
--- a/odoo/modules/loading.py
+++ b/odoo/modules/loading.py
@@ -568,7 +568,10 @@ def load_modules(db, force_demo=False, status=None, update_module=False):
         # is False.
         env = api.Environment(cr, SUPERUSER_ID, {})
         for model in env.values():
-            model._register_hook()
+            if model._name in ('multicompany.config', 'multicompany.security'):
+                model._register_hook(update_module=update_module)
+            else:
+                model._register_hook()
         env['base'].flush()
 
         # STEP 9: save installed/updated modules for post-install tests
diff --git a/odoo/modules/registry.py b/odoo/modules/registry.py
index d17caac09..3ab7c967e 100644
--- a/odoo/modules/registry.py
+++ b/odoo/modules/registry.py
@@ -282,7 +282,10 @@ class Registry(Mapping):
         # on a fully loaded registry, and not on a registry being loaded.
         if self.ready:
             for model in env.values():
-                model._register_hook()
+                if model._name in ('multicompany.config', 'multicompany.security'):
+                    model._register_hook(update_module=True)
+                else:
+                    model._register_hook()
             env['base'].flush()
 
     def post_init(self, func, *args, **kwargs):
diff --git a/odoo/tools/safe_eval.py b/odoo/tools/safe_eval.py
index f60bb5e91..ae6bbc93c 100644
--- a/odoo/tools/safe_eval.py
+++ b/odoo/tools/safe_eval.py
@@ -326,6 +326,38 @@ def safe_eval(expr, globals_dict=None, locals_dict=None, mode="eval", nocopy=Fal
             locals_dict = {}
         locals_dict.update(_BUILTINS)
     c = test_expr(expr, _SAFE_OPCODES, mode=mode)
+    if mode == 'exec':
+        # Untrusted code should NOT use the database cursor to execute SQL commands!
+        # That would bypass all the security rules!
+        # key = unsafe
+        # value = list of safe exceptions
+        unsafe_except = {
+            'cache': [],
+            '.cr': ['.create'],
+            '._cr': ['._cron'],
+            '.execute': [],
+            '._execute': [],
+            '.with': [],
+            '._with': [],
+            '.sql': [],
+            '._sql': [],
+            '.sudo': [],
+            '._sudo': [],
+            '._': [],
+            '__': [],
+        }
+        if 'env' in globals_dict and globals_dict['env'].su == True:
+            # With superuser privileges, allow private methods
+            del unsafe_except['._']
+        testexpr = expr.decode() if isinstance(expr, bytes) else expr
+        for text in unsafe_except:
+            if text in testexpr:
+                count_total = expr.count(text)
+                safe_exceptions = unsafe_except[text]
+                count_safe = sum([expr.count(safe) for safe in safe_exceptions])
+                count_unsafe = count_total - count_safe
+                if count_unsafe:
+                    raise odoo.exceptions.UserError('safe_eval: The code cannot have this phrase:  {}'.format(text))
     try:
         return unsafe_eval(c, globals_dict, locals_dict)
     except odoo.exceptions.except_orm:
